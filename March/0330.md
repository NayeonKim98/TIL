# âœ… ìˆ«ì ì¡°í•© ìƒì„±ê¸° (ì¤‘ë³µí—ˆìš© or ìˆœì—´)
N, Type = map(int, input().split())
nums = []  # ìˆ«ì ì¡°í•©ì„ ì €ì¥í•  ë¦¬ìŠ¤íŠ¸
used = [False] * 7  # ìˆœì—´(ì¤‘ë³µ X)ì¼ ë•Œ ì‚¬ìš© ì¶”ì ìš©

def recur(depth):
    if depth == N:
        print(*nums)
        return

    for i in range(1, 7):  # 1ë¶€í„° 6ê¹Œì§€ ì‹œë„
        if Type == 2 and used[i]:  # ìˆœì—´ì¸ë° ì´ë¯¸ ì‚¬ìš©í•œ ìˆ«ìë©´ pass
            continue
        nums.append(i)
        if Type == 2:
            used[i] = True
        recur(depth + 1)
        nums.pop()
        if Type == 2:
            used[i] = False

recur(0)
```

```python
# âœ… ì¹´ë“œ ì¡°í•© ì¤‘ ì—°ì† 3ì¥ì´ ê°™ì€ ê²½ìš°ì˜ ìˆ˜ ì°¾ê¸°
cards = ['A', 'J', 'Q', 'K']
N = 5
total = 0

def check(combo):
    for i in range(len(combo) - 2):
        if combo[i] == combo[i+1] == combo[i+2]:
            return True
    return False

def generate(depth, result):
    global total
    if depth == N:
        if check(result):
            total += 1
        return

    for c in cards:
        result.append(c)
        generate(depth + 1, result)
        result.pop()

generate(0, [])
print("ì¡°ê±´ì„ ë§Œì¡±í•˜ëŠ” ê²½ìš°ì˜ ìˆ˜:", total)
```

```python
# âœ… DPë¡œ í‘¸ëŠ” ìµœì†Œ ì—ë„ˆì§€ ì†Œëª¨ ê²½ë¡œ
# ì˜ˆì œ ìˆ«ìíŒ
grid = [
    [1, 2, 4],
    [2, 3, 4],
    [1, 5, 5]
]

N = len(grid)
dp = [[0]*N for _ in range(N)]
dp[0][0] = grid[0][0]

for j in range(1, N):
    dp[0][j] = dp[0][j-1] + grid[0][j]
for i in range(1, N):
    dp[i][0] = dp[i-1][0] + grid[i][0]

for i in range(1, N):
    for j in range(1, N):
        dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]

print("ìµœì†Œ ì—ë„ˆì§€ ì†Œëª¨:", dp[N-1][N-1])
```

```python
# âœ… ë¹„íŠ¸ë§ˆìŠ¤í¬ë¡œ ë¶€ë¶„ì§‘í•© êµ¬í•˜ê¸°
arr = ['A', 'B', 'C']
n = len(arr)

def get_sub(tar):
    for i in range(n):
        if tar & 0x1:
            print(arr[i], end=' ')
        tar >>= 1

for tar in range(0, 1 << n):
    print('{', end='')
    get_sub(tar)
    print('}')
```

```python
# âœ… ë¹„íŠ¸ë§ˆìŠ¤í¬ë¥¼ í™œìš©í•œ ì¡°ê±´ ì¡°í•© ê°œìˆ˜ ê³„ì‚°
n = 5
answer = 0

def get_count(target):
    cnt = 0
    while target > 0:
        if target & 1:
            cnt += 1
        target >>= 1
    return cnt

for target in range(1, 1 << n):
    if get_count(target) >= 2:
        answer += 1

print(answer)  # ğŸ‘‰ 26 ì¶œë ¥
```

```python
# âœ… 2ì°¨ì› DPë¡œ í‘¸ëŠ” 0-1 Knapsack
items = [(5, 50), (10, 60), (20, 140)]
max_weight = 30
n = len(items)

dp = [[0] * (max_weight + 1) for _ in range(n + 1)]

for i in range(1, n + 1):
    w, v = items[i - 1]
    for j in range(max_weight + 1):
        if j < w:
            dp[i][j] = dp[i - 1][j]
        else:
            dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - w] + v)

print(f"ë„ë‘‘ì˜ ìµœëŒ€ ì´ë“ì€ {dp[n][max_weight]}ë§Œì›ì…ë‹ˆë‹¤.")
```

```python
# âœ… 1ì°¨ì› DPë¡œ í‘¸ëŠ” 0-1 Knapsack
items = [(5, 50), (10, 60), (20, 140)]
max_weight = 30

dp = [0] * (max_weight + 1)

for w, v in items:
    for j in range(max_weight, w - 1, -1):
        dp[j] = max(dp[j], dp[j - w] + v)

print(f"ë„ë‘‘ì˜ ìµœëŒ€ ì´ë“ì€ {dp[max_weight]}ë§Œì›ì…ë‹ˆë‹¤.")
```

```python
# âœ… Prim ì•Œê³ ë¦¬ì¦˜ (ìµœì†Œ ì‹ ì¥ íŠ¸ë¦¬)
import heapq

def prim(start, graph, V):
    visited = [False] * (V + 1)
    heap = [(0, start)]
    total_cost = 0

    while heap:
        cost, u = heapq.heappop(heap)
        if visited[u]:
            continue
        visited[u] = True
        total_cost += cost

        for v, w in graph[u]:
            if not visited[v]:
                heapq.heappush(heap, (w, v))

    return total_cost
```

```python
# âœ… Kruskal ì•Œê³ ë¦¬ì¦˜ (ìµœì†Œ ì‹ ì¥ íŠ¸ë¦¬)
def find(parent, x):
    if parent[x] != x:
        parent[x] = find(parent, parent[x])
    return parent[x]

def union(parent, a, b):
    a_root = find(parent, a)
    b_root = find(parent, b)
    if a_root != b_root:
        parent[b_root] = a_root

def kruskal(V, edges):
    parent = [i for i in range(V + 1)]
    edges.sort(key=lambda x: x[2])
    total_cost = 0
    for u, v, weight in edges:
        if find(parent, u) != find(parent, v):
            union(parent, u, v)
            total_cost += weight
    return total_cost
```

```python
# âœ… Dijkstra ì•Œê³ ë¦¬ì¦˜ (ìµœë‹¨ ê±°ë¦¬)
import heapq

def dijkstra(start, graph, V):
    distance = [float('inf')] * (V + 1)
    distance[start] = 0

    heap = [(0, start)]

    while heap:
        dist, u = heapq.heappop(heap)
        if dist > distance[u]:
            continue
        for v, weight in graph[u]:
            new_dist = dist + weight
            if new_dist < distance[v]:
                distance[v] = new_dist
                heapq.heappush(heap, (new_dist, v))

    return distance
```

---

ğŸ“ **ì¶”ê°€ íŒ(Tips)**:
- `bitmask`ëŠ” ë¶€ë¶„ì§‘í•©, ì¡°í•© íƒìƒ‰ì— ë§¤ìš° ìœ ìš©í•´ìš”!
- `Knapsack` ë¬¸ì œì—ì„œ 1ì°¨ì› DPëŠ” ë©”ëª¨ë¦¬ ì ˆì•½ì— ì¢‹ì•„ìš”!
- `MST`ëŠ” ë¬´ì¡°ê±´ `Prim` vs `Kruskal` ë‘˜ ë‹¤ ì™¸ìš°ê¸°!
- `Dijkstra`ëŠ” `heapq` ìš°ì„ ìˆœìœ„ íë¥¼ ì¨ì•¼ ë¹ ë¦…ë‹ˆë‹¤!